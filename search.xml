<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MarkDown常用语法]]></title>
    <url>%2F2019%2F02%2F24%2FMarkDown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[因为HEXO的文章基于markdown，而我写博客又比较随缘，有时时间久了有些语法也就忘了，故在此收录下用过markdown语法，以便之后查阅(持续更新) 1 标题写法一1# [标题名称] //#的个数表示标题的级数，最多支持六级标题 示例123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果一级标题二级标题三级标题四级标题五级标题六级标题写法二1234[标题内容]------------- //多个-[标题内容]============= //多个= 最多两级标题 示例1234一级标题-------------二级标题============= 效果一级标题二级标题2 列表2.1 有序列表写法1[序号]. [列表内容] 示例1234560. 一级有序列表 0. 二级有序列表 2. 二级有序列表 2. 三级有序列表3. 一级有序列表2. 一级有序列表 效果 一级有序列表 二级有序列表 二级有序列表 三级有序列表 一级有序列表 一级有序列表 PS:markdown的有序列表支持多层渲染，但在渲染有序列表时仅有第一级列表会从0开始递增 2.2 无序列表写法1[* or + or -] [列表名] 示例12345678910* 无序列表+ 无序列表- 无序列表+ 无序列表 1. 有序列表 2. 有序列表- 无序列表 + 无序列表 1. 有序列表 效果 无序列表 无序列表 无序列表 无序列表 有序列表 有序列表 无序列表 无序列表 有序列表 PS:hexo里的markdown测试后好像不支持无序列表内嵌有序列表（会将其渲染为无序列表），网上看其他网站比如简书等是支持该用法的。 3 引用写法1&gt; [引用内容] 示例123456&gt; 引用&gt;&gt; 多级引用&gt;&gt;&gt;&gt; 多级引用&gt;&gt; 多级引用&gt;&gt; 多级引用 效果 引用 多级引用 多级引用多级引用 多级引用 PS:在多级引用之后若要退出之前的递归需要添加空行重新进行引用。 4 分割线写法12--------- // 三个及以上********* // 三个及以上 示例1234----------************ 效果 可以发现效果是一样的 5 超链接写法12[超链接内容](url &quot;title&quot;)&lt;a href=&quot;url&quot; target=&quot;_blank&quot;&gt;超链接内容&lt;/a&gt; 说明 url：超链接地址 title：鼠标停留时显示的注释 target：即的target作用，表示定向的窗口名，未找到便会打开新的窗口 示例1234[百度](https://www.baidu.com)[Google](https://www.google.com &quot;谷歌&quot;)&lt;a href=&quot;https://www.xidian.edu.cn&quot; target=&quot;_blank&quot;&gt;Xidian&lt;/a&gt; 效果百度Google Xidian PS:默认情况下，Hexo生成的超链接都是绝对地址。例如，如果网站域名为example.com,文章名为hello，那么绝对链接可能像这样：http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。 6 图片写法1![Alt text](url &quot;title&quot;) 说明 Alt text：图片的Alt标签，用来描述图片的关键词，可以不写。最初的本意是当图片因为某种原因不能被显示时而出现的替代文字，后来又被用于SEO，可以方便搜索引擎根据Alt text里面的关键词搜索到图片 url：图片url，支持相对地址与绝对地址，同理也支持以绝对地址为链接的网络图片 title：图片的标题文字，鼠标悬停即可显示 示例1![网络图片](https://fgo.wiki/images/e/ea/%E4%B8%A4%E4%BB%AA%E5%BC%8F%28Saber%29-%E5%A4%B4%E5%83%8F1.png &quot;两仪式&quot;) 效果 7 文本7.1 强调写法123**[强调文本]***[斜体文本]*~~[删除线文本]~~ 示例123**这是个粗体段落***这是个斜体段落*~~这是个删除线段落~~ 效果这是个粗体段落这是个斜体段落这是个删除线段落 7.2 字体写法1&lt;font face=&quot;字体&quot; size=&quot;字号&quot; color=&quot;颜色&quot;&gt;文本&lt;/font&gt; 说明: 字体(face)：常用字体均有支持，例如黑体， 宋体， 微软雅黑， 楷体等。 字号(size)：取值范围[1-7], 默认取值为3。 颜色(color)：支持三种格式，包括名称（red、blue、green等）、RGB值（0，0，255等）、3字节编码（#0000FF等） 示例1234&lt;font face=&quot;黑体&quot; size=&quot;10&quot; color=&quot;red&quot;&gt;黑体10号红色&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot; size=&quot;20&quot; color=&quot;black&quot;&gt;雅黑20号黑色&lt;/font&gt;&lt;font face=&quot;楷体&quot; size=&quot;30&quot; color=&quot;green&quot;&gt;楷体30号绿色&lt;/font&gt;&lt;font face=&quot;华文行楷&quot; size=&quot;7&quot; color=&quot;blue&quot;&gt;行楷7号蓝色&lt;/font&gt; 效果黑体2号红色雅黑4号黑色楷体6号绿色行楷7号蓝色 8 代码写法1234567`[单行代码]` \单行代码```(语言标识) \\多行代码 [code1... code2... code3]``` 示例1234567```c++ #include&lt;iostream&gt; using namespace std; int main() &#123; cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; &#125;``` 效果12345#include&lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; "Hello, World!" &lt;&lt; endl;&#125; 9 表格写法1234表头|表头|表头-|:-:|-:内容|内容|内容内容|内容|内容 说明 - 默认格式 :- 左对齐 -：右对齐 :-：居中 示例1234表头一|表头二|表头三:-|:-:|-:左对齐|居中|右对齐内容一|内容二|内容三 效果 表头一 表头二 表头三 左对齐 居中 右对齐 内容一 内容二 内容三 10 流程图示例1234567891011121314151617` ``flowst=&gt;start: Start|past:&gt;http://www.google.com[blank]e=&gt;end: End:&gt;http://www.google.comop1=&gt;operation: My Operation|pastop2=&gt;operation: Stuff|currentsub1=&gt;subroutine: My Subroutine|invalidcond=&gt;condition: Yesor No?|approved:&gt;http://www.google.comc2=&gt;condition: Good idea|rejectedio=&gt;inputoutput: catch something...|requestst-&gt;op1(right)-&gt;condcond(yes, right)-&gt;c2cond(no)-&gt;sub1(left)-&gt;op1c2(yes)-&gt;io-&gt;ec2(no)-&gt;op2-&gt;e``` PS:hexo中显示markdown的流程图需要下载hexo-filter-flowchart插件才能正常显示，因为该插件会直接将代码块转译为HTML，无法在MARKDOWN的代码块中显示，所以在```中加了空格方便对比 效果 其他 st=>start: Start|past:>http://www.google.com[blank] e=>end: End:>http://www.google.com op1=>operation: My Operation|past op2=>operation: Stuff|current sub1=>subroutine: My Subroutine|invalid cond=>condition: Yes or No?|approved:>http://www.google.com c2=>condition: Good idea|rejected io=>inputoutput: catch something...|request st->op1(right)->cond cond(yes, right)->c2 cond(no)->sub1(left)->op1 c2(yes)->io->e c2(no)->op2->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>MARKDOWN</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO常用命令]]></title>
    <url>%2F2019%2F02%2F24%2FHEXO%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[呜呜呜~~，Steam寒假折扣又喜+1，寒假学习计划又泡汤了，G胖真可恶！（MHW真好玩！隔了好久，突然发现hexo的那些命令又忘光了….. so，搬运下官网的常用命令，以后方便查阅。我们不生产知识，我们只是大自然的搬运工，内容来源 init$ hexo init [folder]新建一个网站。如果没有设置folder，Hexo默认在目前的文件夹建立网站。 new]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂]]></title>
    <url>%2F2018%2F10%2F25%2F%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[快速幂问题描述求解$a^b%c$其中$1\leq a,b,c\leq 10^9$ 算法描述首先需要知道模运算的乘法运算规则 : (a b) % p = (a % p b % p) % p根据上面的规则，可以想到一种最朴素的快速幂算法，即将a依次累乘，同时不停对中间值进行取模运算，这不失为一种可行方案，但其复杂度为O(n)，即使采取分治算法其时间复杂度也不会有明显下降，而快速幂算法的时间复杂度为O(log(n))，可以有效降低其运算时间。学过计算机组成原理后我们知道整数在计算机中为二进制存储，由此我们可以将原式表示如下$$a^{(2^{b_1}+2^{b_2}+…+2^{b_n})}$$其中$0\leq b_1,b_2,\ldots,b_n\leq 1,b_n$代表b的二进制位中第n位的值，这样便可根据b的二进制位的权重对$b_1,b_2,\ldots,b_n$依次进行判断，若为真则乘以相应权重，这样只需将b的所有二进制位进行判断即可。 实现代码123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll qmod(ll a, ll b, ll c) &#123; ll ans = 1; while (b) &#123; // 依次判断二进制位 if (b &amp; 1) ans = (ans * a) % c; a = (a * a) % c; // 同步更新对应位置权重 b &gt;&gt;= 1; &#125; return ans;&#125;int main() &#123; ll a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; qmod(a, b, c) &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop学习笔记(HDFS)]]></title>
    <url>%2F2018%2F10%2F25%2FHadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88HDFS%EF%BC%89%2F</url>
    <content type="text"><![CDATA[HDFS]]></content>
      <categories>
        <category>Hadoop</category>
        <category>HDFS</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>HDFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPOT学习笔记(SPOT-UI)]]></title>
    <url>%2F2018%2F10%2F19%2FSPOT-UI%2F</url>
    <content type="text"><![CDATA[APACHE SPOT简介 INTRODUCTIONApache Spot是一个基于网络流量和数据包分析，通过独特的机器学习方法，发现潜在安全威胁和未知网络攻击能力的开源方案。目前Apache Spot 已支持对Netflow、sflow、DNS、Proxy的网络流量分析，主要依靠HDFS、Hive 提供存储能力，Spark提供计算能力，基于LDA算法提供无监督式机器学习能力，最终依赖Jupyter 提供图形化交互能力，产生少量且准确的安全威胁事件呈现给用户。 数据采集 SPOT-IngestSpot克服了如何提高从不同数据源中进行数据采集的挑战，尤其是大多数时间，采集器每秒发送远超过服务器可用资源（CPU，内存）的数以千计的网络事件。借助Spot，可以确保服务可用性接近100%，且不会丢失数据。Spot可以在需要时启用更快速，可扩展的分布式服务。由于其分布式体系结构，当执行采集器守护程序的数据节点在高峰工作负载崩溃，致使数据排队时，不会发生数据丢失。这种架构确保可用性接近99.99999%，而不会损失信息。 采集模块内部Spot-Collectors守护进程在后台对文件系统路径进行监视或者采集。采集器检测通过网络工具产生的新文件或留在路径中用以采集的之前产生的数据。随后，采集器使用解剖工具（例如nfdump或tshark）将这些数据转换为可读的格式。 Kafka对每个采集进程的实例创建一个新的主题。分块由采集中的Workers数量来定义。Kafka存储采集器发送来的数据，并由Worker来解析数据。 Spot Workers和采集器一样，Workers是后台运行的守护进程，关注特定的Kafka主题和分块。Spot Workers读取、解析并将数据存储在特定的Hive表中，随后用于机器学习算法。当前有两种类型的Workers，一是Python Workers，使用多线程和已定义的解析器来处理数据；二是Spark-Streaming Workers，使用spark-streaming上下文（微批处理）执行Spark应用来读取Kafka中的数据。 机器学习 SPOT-MLSpot机器学习组件包含用于对从网络收集的Netflow、DNS、代理日志进行可疑连接分析的例程。分析使用收集的网络事件，并生成被认为最不可能事件的列表，这些事件被认为是最可疑的。它们依赖Spot采集组件来收集加载Netflow、DNS和代理记录。 Spot使用主题模型来发现正常和不正常的行为。它将与某个IP相关的日志集视为一个文档，并使用LDA来发现这些文档集中隐藏的语义结构。 LDA是用于离散数据的生成概率模型，如文本语料库。LDA是一种三层贝叶斯模型，其中文档的每个词都是从一组潜在主题的混合中生成的。我们将LDA应用于网络流量，通过聚合和离散将网络日志条目转换为单词。在这种方式中，文档对应于IP地址，单词对应于日志条目（与IP地址相关的），主题对应于常见网络活动配置。 Spot对每个IP地址的网络行为建立一个概率模型。每个网络日志条目根据模型分配一个估计的可能性（分数）。这些低分事件会被标注为“可疑的”，用于以后的分析。 可视化 SPOT-OASpot-OA基于IPython、D3JS、jQuery、Bootstrap、ReactJS技术向用户提供数据处理、转换以及数据可视化的能力。当前版本主要通过Suspicious、Threat Investigation、Story Board三个视图页面提供针对Flow、DNS、Proxy事件的可视化分析能力。此外，通过Ingest Summary Notebook视图页面，提供了解指定时间段内数据采集情况的能力。 可疑分析 (suspicious.html)通过查看Apache Spot的机器学习算法检测到的安全威胁列表来研究可疑的网络活动。Suspicious视图页面用于呈现Spot-ML发现的可疑活动，主要由四个面板组成。 Suspicious以数据列表的形式展现Spot-ML 发现的可疑活动；Network View以可视化的形式表现这些可疑活动；Details用于挖掘某个可疑活动更为细节的信息。Scoring提供一种专家能力，通过人为介入的方式修正或改善机器学习模型。 NetFlow Suspicious DNS Suspicious Suspicious 通过选择可疑帧中的特定行，将突出显示网络视图中的连接。 通过执行此行选择，“详细信息框架”显示在与选择的可疑记录同一分钟内发生的源和目标IP地址之间的所有Netflow记录。 IP地址带有附加信息，显示该IP的信誉值及地理位置信息上下文。 Network 显示节点IP，右击该节点可对信息进行过滤，只显示与该IP有关的流信息，以便将IP过滤器应用于可疑网页。 左击网络节点，在Details中显示该IP与其他IP连接的和弦图 Scoring此框架包含一个部分，分析人员可以使用不同的值对IP地址和端口进行评分。为了给特定连接分配风险，请使用所有组合框的组合选择它，选择正确的风险评级（1 =高风险，2=中等/潜在风险，3=低/已接受风险）并点击分数按钮。从每个列表中选择一个值将缩小巧合，因此如果分析师希望使用一个相同的相关属性（即src端口80）对所有连接进行评分，则只选择相关的组合框，并将其余部分保留在第一行在顶部。 威胁调查 Threat Investigation (threat-investigation.html)Threat Investigation视图页面是分析结果展示在Storyboard之前的最后一步，安全分析师在这个页面对即将展示的分析结果进行最后一步核查。从列表中选择任何IP，然后单击“Search”可以查看有关它的特定详细信息。将执行对流表的查询，查看最初收集的原始数据，以查找白天与任何其他IP地址之间的所有通信，收集其他信息，例如： max&amp;avg发送/接收的字节数 max&amp;avg发送/接收的数据包数 目的端口 源端口 第一个和最后一个连接时间 连接数 根据查询的结果，该模块将显示包含结果的表，其中包含以下信息： 每个连接数的顶部IP 传输的每个字节的顶级IP 可以通过更新top_results变量的值来设置存储在字典（n）中的结果数。 故事板 Story Board (storyboard.html)Storyboard视图页面用于呈现系统最终的分析结果，供用户掌握高风险的安全威胁事件以及更进一步的信息。 事件进展 影响分析 地理位置 时间时间轴 NetFlow Story Board DNS Story BoardIngest Summary 用于了解系统的数据采集情况，可以查看采集的数据类型在指定时间段的数据量分布详情。 参考 Reference[1] http://blog.nsfocus.net/apache-spot/#1_Apache_Spot[2] http://spot.apache.org/doc/]]></content>
      <categories>
        <category>Hadoop</category>
        <category>SPOT</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>SPOT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
